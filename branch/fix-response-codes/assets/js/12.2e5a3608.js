(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{306:function(e,t,a){e.exports=a.p+"assets/img/osi_layers.67f8a7c8.png"},307:function(e,t,a){e.exports=a.p+"assets/img/communication_channels.e239da73.png"},395:function(e,t,a){"use strict";a.r(t);var r=a(42),o=Object(r.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"general-protocol-concept"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#general-protocol-concept"}},[e._v("#")]),e._v(" General Protocol Concept")]),e._v(" "),r("p",[e._v("The ThingSet protocol provides a consistent, standardized way to configure, monitor and control ressource-constrained devices via different communication interfaces. It specifies the higher layers (5 to 7) of the "),r("a",{attrs:{href:"https://en.wikipedia.org/wiki/OSI_model",target:"_blank",rel:"noopener noreferrer"}},[e._v("OSI (Open Systems Interconnection) model"),r("OutboundLink")],1),e._v(". The payload data is independent of the underlying lower layer protocol or interface, which can be CAN, USB, LoRa, WiFi, Bluetooth, UART (serial) or similar.")]),e._v(" "),r("p",[r("img",{attrs:{src:a(306),alt:"ISO/OSI layer setup"}})]),e._v(" "),r("p",[e._v("The underlying layers have to ensure encryption, reliable transfer, correct packet order (if messages are packetized) and error-checking of the transferred data.")]),e._v(" "),r("h2",{attrs:{id:"message-types"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#message-types"}},[e._v("#")]),e._v(" Message Types")]),e._v(" "),r("p",[e._v("ThingSet defines three types of messages: Requests, responses and publication messages.")]),e._v(" "),r("h3",{attrs:{id:"request-response-or-client-server-model"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#request-response-or-client-server-model"}},[e._v("#")]),e._v(" Request/response or client/server model")]),e._v(" "),r("p",[e._v("The communication between two specific devices uses a request/response messaging pattern via so-called channels. A communication channel can be established either directly (e.g. serial interface, USB, Bluetooth) or via a network or bus with several devices attached (e.g. CAN, Ethernet, WiFi, LoRa). In case of a network, each device/node has to be uniquely addressable.")]),e._v(" "),r("p",[r("img",{attrs:{src:a(307),alt:"Communication Channels"}})]),e._v(" "),r("p",[e._v("The device acts as the server and responds to the requests by a client. The client might be a laptop or mobile phone with a human interface application.")]),e._v(" "),r("p",[e._v("The data transfer is always synchronous: The client sends a request, waits for the response (status code and/or requested data), handles the data of the response and possibly starts with additional requests.")]),e._v(" "),r("h3",{attrs:{id:"publication-messages"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#publication-messages"}},[e._v("#")]),e._v(" Publication messages")]),e._v(" "),r("p",[e._v("Monitoring data is not intended for only a single device, but could be interesting for several devices (e.g. data logger, display, human interface device, etc.). Thus, the monitoring data is exchanged via a publish/subscribe messaging pattern.")]),e._v(" "),r("p",[e._v("Publication messages are directly broadcast through the network. There is "),r("em",[e._v("no")]),e._v(" intermediate broker (like in MQTT) to store the messages and published messages are "),r("em",[e._v("not")]),e._v(" confirmed by recipients, so there is no guarantee if the message was received.")]),e._v(" "),r("h2",{attrs:{id:"protocol-modes"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#protocol-modes"}},[e._v("#")]),e._v(" Protocol Modes")]),e._v(" "),r("p",[e._v("Similar to Modbus, the ThingSet protocol supports two different modes: A human-readable text mode and a binary mode.")]),e._v(" "),r("p",[e._v("In the text mode, payload data is encoded in JSON format ("),r("a",{attrs:{href:"https://tools.ietf.org/html/rfc8259",target:"_blank",rel:"noopener noreferrer"}},[e._v("RFC 8259"),r("OutboundLink")],1),e._v("). This mode is recommended when using USB or serial interfaces as the low layer protocol, as it can be easily used directly on a terminal.")]),e._v(" "),r("p",[e._v("The binary protocol uses the CBOR binary encoding ("),r("a",{attrs:{href:"https://tools.ietf.org/html/rfc7049",target:"_blank",rel:"noopener noreferrer"}},[e._v("RFC 7049"),r("OutboundLink")],1),e._v(") instead of JSON payload data in order to reduce the protocol overhead for ressource-constrained devices or low bandwith communication protocols like CAN and LoRa.")]),e._v(" "),r("p",[e._v("Each device must implement the binary encoding of the protocol. The the text-based JSON variant is optional, but recommended.")]),e._v(" "),r("h2",{attrs:{id:"data-objects"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#data-objects"}},[e._v("#")]),e._v(" Data Objects")]),e._v(" "),r("p",[e._v("All accessible data of a device is structured in so-called data objects. A data object might be any kind of measurements (e.g. temperature), device configuration (e.g. setpoint of a controller) or similar.")]),e._v(" "),r("p",[e._v('Each data object is identified by a unique Data Object ID. The ID can be chosen by the firmware developer. In addition to that, each data object has a unique name. The name is a short case-sensitive ASCII string without blanks. If applicable, the unit is appended with an underscore, e.g. "Bat_V" for the battery voltage or "Manufacturer" (without a unit). The underscore is only allowed to separate the name and the unit, there is no additional underscore allowed in the name.')]),e._v(" "),r("p",[e._v("The numeric IDs are used in the binary protocol to reduce message length. For all interactions with users and in the text-based mode, only the object name is used.")]),e._v(" "),r("h3",{attrs:{id:"data-object-categories"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#data-object-categories"}},[e._v("#")]),e._v(" Data object categories")]),e._v(" "),r("p",[e._v("Each data object belongs to one of the following categories:")]),e._v(" "),r("table",[r("thead",[r("tr",[r("th",[e._v("Category")]),e._v(" "),r("th",[e._v("Description")]),e._v(" "),r("th",[e._v("Access")])])]),e._v(" "),r("tbody",[r("tr",[r("td",[e._v("info")]),e._v(" "),r("td",[e._v("Device information (e.g. manufacturer, software version)")]),e._v(" "),r("td",[e._v("read access")])]),e._v(" "),r("tr",[r("td",[e._v("conf")]),e._v(" "),r("td",[e._v("Configurable settings, stored in non-volatile memory after change")]),e._v(" "),r("td",[e._v("read/write access, may be protected with user password")])]),e._v(" "),r("tr",[r("td",[e._v("input")]),e._v(" "),r("td",[e._v("Input channels (e.g. actuators)")]),e._v(" "),r("td",[e._v("write access")])]),e._v(" "),r("tr",[r("td",[e._v("output")]),e._v(" "),r("td",[e._v("Output channels (e.g. sensor data)")]),e._v(" "),r("td",[e._v("read access")])]),e._v(" "),r("tr",[r("td",[e._v("rec")]),e._v(" "),r("td",[e._v("Recorded (history-dependent) data (e.g. error counters)")]),e._v(" "),r("td",[e._v("read access, restricted write access to reset")])]),e._v(" "),r("tr",[r("td",[e._v("cal")]),e._v(" "),r("td",[e._v("Factory-calibrated settings")]),e._v(" "),r("td",[e._v("read/write access, protected")])]),e._v(" "),r("tr",[r("td",[e._v("exec")]),e._v(" "),r("td",[e._v("Executable data (remote procedure call)")]),e._v(" "),r("td",[e._v("partly access restricted")])])])]),e._v(" "),r("p",[e._v("The input and output channels are used for instantaneous data. Changes to an input data object are only stored in RAM, so they get lost after a reset of the device. In contrast to that, conf data is stored in non-volatile memory (e.g. flash or EEPROM) after a change. As non-volatile memory has a limited amount of write cycles, configuration data should not be changed continously.")]),e._v(" "),r("p",[e._v("The recorded data category is used for history-dependent data like error memory, energy counters or min/max values of certain measurements. In contrast to data of "),r("em",[e._v("output")]),e._v(" category, recorded data cannot be obtained through measurement after reset, so the current state has to be stored in non-volatile memory on a regular basis.")]),e._v(" "),r("p",[e._v("Factory calibration is only accessible for the manufacturer after authentication.")]),e._v(" "),r("p",[e._v("Excecutable data means that they trigger a function call in the device firmware. Currently, only void functions without any parameters are supported.")]),e._v(" "),r("p",[e._v("Data object IDs are stored as unsigned integers. The firmware developer should assign the lowest IDs to the most used data objects, as they consume less bytes during transfer (see CBOR representation of unsigned integers).")]),e._v(" "),r("h3",{attrs:{id:"examples"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#examples"}},[e._v("#")]),e._v(" Examples")]),e._v(" "),r("p",[e._v("For explanation of the protocol functions, the following exemplary device data objects will be used:")]),e._v(" "),r("table",[r("thead",[r("tr",[r("th",[e._v("Data Object ID")]),e._v(" "),r("th",[e._v("Name")]),e._v(" "),r("th",[e._v("Value")]),e._v(" "),r("th",[e._v("Category")])])]),e._v(" "),r("tbody",[r("tr",[r("td",[e._v("0x01")]),e._v(" "),r("td",[e._v("Manufacturer")]),e._v(" "),r("td",[e._v('"Test Company Inc."')]),e._v(" "),r("td",[e._v("info")])]),e._v(" "),r("tr",[r("td",[e._v("0x02")]),e._v(" "),r("td",[e._v("EnableSwitch")]),e._v(" "),r("td",[e._v("true")]),e._v(" "),r("td",[e._v("input")])]),e._v(" "),r("tr",[r("td",[e._v("0x03")]),e._v(" "),r("td",[e._v("Bat_V")]),e._v(" "),r("td",[e._v("14.2")]),e._v(" "),r("td",[e._v("output")])]),e._v(" "),r("tr",[r("td",[e._v("0x04")]),e._v(" "),r("td",[e._v("Ambient_degC")]),e._v(" "),r("td",[e._v("22")]),e._v(" "),r("td",[e._v("output")])])])]),e._v(" "),r("p",[e._v("The above data structure contains 4 data objects in total, grouped into 3 different categories (info, input and output). The device will have an internal map to associate the object name, unique ID, category and a pointer to the variable containing the actual data.")]),e._v(" "),r("h3",{attrs:{id:"units"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#units"}},[e._v("#")]),e._v(" Units")]),e._v(" "),r("p",[e._v("All data communicated with the outside world use "),r("a",{attrs:{href:"https://en.wikipedia.org/wiki/International_System_of_Units",target:"_blank",rel:"noopener noreferrer"}},[e._v("SI units"),r("OutboundLink")],1),e._v(" and the different numeric data types should be used for scaling instead of prefixes like "),r("em",[e._v("milli")]),e._v(" or "),r("em",[e._v("kilo")]),e._v(" to the units.")]),e._v(" "),r("p",[e._v('If the basic SI unit for a given measurement value is not common or not feasible (e.g. use of kWh for energy instead of Ws), the unit must be properly defined with an underscore in the name of the data object, e.g. "Battery_kWh" for the battery energy content in kWh. Units which cannot be derived from the SI basic units (e.g. Â°F) are not recommended.')]),e._v(" "),r("h2",{attrs:{id:"functions"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#functions"}},[e._v("#")]),e._v(" Functions")]),e._v(" "),r("p",[e._v("Each request fulfills a specified function, e.g. a command to read data from the device. The function is associated to a function ID, which defines the layout of the payload and the actions to be performed.")]),e._v(" "),r("p",[e._v("The different functions are encoded in the first byte of a message, i.e. by a number between 0 and 255.")]),e._v(" "),r("p",[e._v("Function IDs 10, 13 and 32-127 are reserved, as they represent the ASCII characters for readable text including CR and LF. Invalid function IDs are ignored by the ThingSet parser, so that other text output (e.g. status information) can be used in parallel to the ThingSet protocol on the same serial interface.")]),e._v(" "),r("p",[e._v("The ASCII characters '!', '#' and ':' (function IDs 33, 35 and 58) are used as identifiers for the text mode protocol. In this way, text-based or binary mode can be automatically detected based on the first byte.")]),e._v(" "),r("p",[e._v("Function IDs greater than or equal to 128 (0x80) are used for response messages and include a status code which shows if the request could be handled successfully. The function ID is calculated as 0x80 + status code. For status codes between 0 and 31, the response was successful. If the status code is greater than or equal to 32, an error occured.")]),e._v(" "),r("p",[e._v("Details regarding the ThingSet Protocol functions will be explained in the next chapter.")])])}),[],!1,null,null,null);t.default=o.exports}}]);